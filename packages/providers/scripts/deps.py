#!/usr/bin/env python3
"""
üìä Dependencies Script - Slice/ALIVE Providers Server
An√°lise de depend√™ncias, licen√ßas e auditoria de seguran√ßa.

Princ√≠pios CONCEPTS.md:
- Curadoria de Licen√ßa: An√°lise obrigat√≥ria antes de adotar
- Baixo Recurso: Depend√™ncias m√≠nimas e justificadas
- Valida√ß√£o Forte: JSON Schema para reports
- Justificativa Real: Documenta√ß√£o de escolhas t√©cnicas
"""

import json
import logging
import subprocess
import sys
from datetime import datetime
from pathlib import Path

import pkg_resources
from jsonschema import ValidationError, validate

# Configura√ß√£o de logging
logging.basicConfig(
    level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s"
)
logger = logging.getLogger(__name__)

# Schema para valida√ß√£o do relat√≥rio de depend√™ncias
DEPS_REPORT_SCHEMA = {
    "type": "object",
    "properties": {
        "timestamp": {"type": "string"},
        "total_packages": {"type": "number"},
        "packages": {
            "type": "array",
            "items": {
                "type": "object",
                "properties": {
                    "name": {"type": "string"},
                    "version": {"type": "string"},
                    "license": {"type": "string"},
                    "size": {"type": "number"},
                    "dependencies": {"type": "array"},
                    "license_risk": {
                        "type": "string",
                        "enum": ["low", "medium", "high", "unknown"],
                    },
                    "justification": {"type": "string"},
                },
                "required": ["name", "version", "license", "license_risk"],
            },
        },
        "license_summary": {"type": "object"},
        "security_issues": {"type": "array"},
        "recommendations": {"type": "array"},
    },
    "required": ["timestamp", "total_packages", "packages", "license_summary"],
}

# Mapeamento de licen√ßas para n√≠vel de risco
LICENSE_RISK_MAP = {
    # Baixo risco - Compatible com CONCEPTS.md
    "MIT": "low",
    "BSD": "low",
    "BSD-2-Clause": "low",
    "BSD-3-Clause": "low",
    "Apache-2.0": "low",
    "Apache Software License": "low",
    "ISC": "low",
    "Unlicense": "low",
    "Python Software Foundation License": "low",
    # Risco m√©dio - An√°lise necess√°ria
    "GPL-2.0": "medium",
    "GPL-3.0": "medium",
    "LGPL-2.1": "medium",
    "LGPL-3.0": "medium",
    "MPL-2.0": "medium",
    "Mozilla Public License 2.0 (MPL 2.0)": "medium",
    # Alto risco - Incompat√≠vel com CONCEPTS.md
    "AGPL-3.0": "high",
    "GPL-3.0-or-later": "high",
    "Copyleft": "high",
    "Commercial": "high",
    "Proprietary": "high",
    # Desconhecido
    "UNKNOWN": "unknown",
    "": "unknown",
    None: "unknown",
}

# Justificativas padr√£o para depend√™ncias core
CORE_JUSTIFICATIONS = {
    "fastapi": "Framework web minimalista, bem tipado, compat√≠vel com valida√ß√£o forte",
    "uvicorn": "Servidor ASGI de alta performance, baixo recurso, open source",
    "transformers": "Biblioteca HuggingFace oficial, CPU-only suportado, modelos offline",
    "torch": "PyTorch para CPU-only, dependency dos transformers, open source",
    "pydantic": "Valida√ß√£o forte via JSON Schema, alinhado com CONCEPTS.md",
    "requests": "HTTP client padr√£o, confi√°vel, baixo recurso",
    "jsonschema": "Valida√ß√£o JSON Schema obrigat√≥ria conforme CONCEPTS.md",
    "pytest": "Framework de testes padr√£o, bem estabelecido",
    "black": "Formata√ß√£o autom√°tica, padr√£o da comunidade Python",
    "isort": "Organiza√ß√£o de imports, integra com black",
    "flake8": "Linting b√°sico, baixo recurso",
    "mypy": "Type checking est√°tico, alinhado com valida√ß√£o forte",
}


def get_installed_packages():
    """
    Obt√©m lista de pacotes instalados no ambiente.

    Returns:
        list: Lista de pacotes com metadados
    """
    logger.info("üì¶ Coletando pacotes instalados...")

    packages = []

    try:
        # Usar pkg_resources para obter informa√ß√µes detalhadas
        for dist in pkg_resources.working_set:
            package_info = {
                "name": dist.project_name,
                "version": dist.version,
                "location": dist.location,
                "dependencies": [str(req) for req in dist.requires()],
                "license": "UNKNOWN",
                "size": 0,
            }

            # Tentar obter licen√ßa dos metadados
            try:
                if hasattr(dist, "get_metadata"):
                    metadata = dist.get_metadata("METADATA")
                    for line in metadata.split("\n"):
                        if line.startswith("License:"):
                            package_info["license"] = line.split(":", 1)[1].strip()
                            break
                        elif line.startswith("Classifier: License ::"):
                            # Extract license from classifier
                            classifier = line.split("::", 2)[-1].strip()
                            package_info["license"] = classifier
                            break
            except:
                pass

            # Tentar calcular tamanho (estimativa b√°sica)
            try:
                location_path = Path(package_info["location"])
                if location_path.exists():
                    # Estimativa simples - pode ser imprecisa
                    package_info["size"] = sum(
                        f.stat().st_size
                        for f in location_path.rglob("*")
                        if f.is_file()
                        and package_info["name"].lower() in str(f).lower()
                    )
            except:
                package_info["size"] = 0

            packages.append(package_info)

    except Exception as e:
        logger.error(f"‚ùå Erro ao coletar pacotes: {e}")

    logger.info(f"üì¶ Encontrados {len(packages)} pacotes")
    return packages


def analyze_license_risk(license_str):
    """
    Analisa risco da licen√ßa baseado em CONCEPTS.md.

    Args:
        license_str: String da licen√ßa

    Returns:
        str: N√≠vel de risco (low, medium, high, unknown)
    """
    if not license_str:
        return "unknown"

    license_str = license_str.strip()

    # Verifica√ß√£o exata
    if license_str in LICENSE_RISK_MAP:
        return LICENSE_RISK_MAP[license_str]

    # Verifica√ß√£o por substring (case insensitive)
    license_lower = license_str.lower()

    for license_key, risk in LICENSE_RISK_MAP.items():
        if license_key and license_key.lower() in license_lower:
            return risk

    # Heur√≠sticas para licen√ßas comuns
    if any(keyword in license_lower for keyword in ["mit", "bsd", "apache"]):
        return "low"
    elif any(keyword in license_lower for keyword in ["gpl", "copyleft"]):
        return "medium"
    elif any(
        keyword in license_lower for keyword in ["agpl", "commercial", "proprietary"]
    ):
        return "high"

    return "unknown"


def get_package_justification(package_name):
    """
    Obt√©m justificativa para uso do pacote.

    Args:
        package_name: Nome do pacote

    Returns:
        str: Justificativa ou mensagem padr√£o
    """
    package_lower = package_name.lower()

    # Verifica√ß√£o direta
    if package_lower in CORE_JUSTIFICATIONS:
        return CORE_JUSTIFICATIONS[package_lower]

    # Verifica√ß√£o por substring
    for core_name, justification in CORE_JUSTIFICATIONS.items():
        if core_name in package_lower or package_lower in core_name:
            return justification

    return "Depend√™ncia transitiva ou utilit√°rio - verificar necessidade"


def run_security_audit():
    """
    Executa auditoria de seguran√ßa com pip-audit.

    Returns:
        list: Lista de vulnerabilidades encontradas
    """
    logger.info("üîí Executando auditoria de seguran√ßa...")

    security_issues = []

    try:
        # Verificar se pip-audit est√° dispon√≠vel
        result = subprocess.run(
            ["pip-audit", "--format=json"], capture_output=True, text=True, timeout=300
        )

        if result.returncode == 0:
            try:
                audit_data = json.loads(result.stdout)
                security_issues = audit_data.get("vulnerabilities", [])
                logger.info(f"üîí Encontradas {len(security_issues)} vulnerabilidades")
            except json.JSONDecodeError:
                logger.warning("‚ö†Ô∏è  Falha ao parsear resultado da auditoria")
        else:
            logger.warning("‚ö†Ô∏è  pip-audit n√£o dispon√≠vel ou falhou")

    except subprocess.TimeoutExpired:
        logger.warning("‚ö†Ô∏è  Auditoria de seguran√ßa expirou (timeout)")
    except FileNotFoundError:
        logger.info("üí° pip-audit n√£o instalado - pulando auditoria de seguran√ßa")
        logger.info("   Para instalar: pip install pip-audit")
    except Exception as e:
        logger.warning(f"‚ö†Ô∏è  Erro na auditoria de seguran√ßa: {e}")

    return security_issues


def generate_recommendations(packages, security_issues):
    """
    Gera recomenda√ß√µes baseadas na an√°lise.

    Args:
        packages: Lista de pacotes analisados
        security_issues: Vulnerabilidades encontradas

    Returns:
        list: Lista de recomenda√ß√µes
    """
    recommendations = []

    # An√°lise de licen√ßas de alto risco
    high_risk_licenses = [pkg for pkg in packages if pkg.get("license_risk") == "high"]
    if high_risk_licenses:
        recommendations.append(
            {
                "type": "license_risk",
                "priority": "high",
                "message": f"Encontradas {len(high_risk_licenses)} depend√™ncias com licen√ßas de alto risco",
                "packages": [pkg["name"] for pkg in high_risk_licenses],
                "action": "Revisar e considerar substitui√ß√£o por alternativas compat√≠veis",
            }
        )

    # Licen√ßas desconhecidas
    unknown_licenses = [pkg for pkg in packages if pkg.get("license_risk") == "unknown"]
    if unknown_licenses:
        recommendations.append(
            {
                "type": "license_unknown",
                "priority": "medium",
                "message": f"Encontradas {len(unknown_licenses)} depend√™ncias com licen√ßas desconhecidas",
                "packages": [pkg["name"] for pkg in unknown_licenses],
                "action": "Investigar licen√ßas e classificar risco manualmente",
            }
        )

    # Pacotes sem justificativa
    no_justification = [
        pkg
        for pkg in packages
        if pkg.get("justification", "").startswith("Depend√™ncia transitiva")
    ]
    if len(no_justification) > 10:  # Threshold para evitar ru√≠do
        recommendations.append(
            {
                "type": "justification",
                "priority": "low",
                "message": f"Muitas depend√™ncias ({len(no_justification)}) sem justificativa espec√≠fica",
                "action": "Revisar necessidade e documentar justificativas",
            }
        )

    # Vulnerabilidades de seguran√ßa
    if security_issues:
        critical_issues = [
            issue for issue in security_issues if issue.get("severity") == "critical"
        ]
        if critical_issues:
            recommendations.append(
                {
                    "type": "security_critical",
                    "priority": "critical",
                    "message": f"Encontradas {len(critical_issues)} vulnerabilidades cr√≠ticas",
                    "action": "Atualizar pacotes vulner√°veis imediatamente",
                }
            )

    return recommendations


def generate_deps_report(packages, security_issues):
    """
    Gera relat√≥rio completo de depend√™ncias.

    Args:
        packages: Lista de pacotes
        security_issues: Vulnerabilidades

    Returns:
        dict: Relat√≥rio estruturado
    """
    logger.info("üìä Gerando relat√≥rio de depend√™ncias...")

    # Enriquecer dados dos pacotes
    enriched_packages = []
    for pkg in packages:
        enriched_pkg = pkg.copy()
        enriched_pkg["license_risk"] = analyze_license_risk(pkg.get("license", ""))
        enriched_pkg["justification"] = get_package_justification(pkg["name"])
        enriched_packages.append(enriched_pkg)

    # Sum√°rio de licen√ßas
    license_summary = {}
    for pkg in enriched_packages:
        license_name = pkg.get("license", "UNKNOWN")
        license_summary[license_name] = license_summary.get(license_name, 0) + 1

    # Gerar recomenda√ß√µes
    recommendations = generate_recommendations(enriched_packages, security_issues)

    report = {
        "timestamp": datetime.now().isoformat(),
        "total_packages": len(enriched_packages),
        "packages": enriched_packages,
        "license_summary": license_summary,
        "security_issues": security_issues,
        "recommendations": recommendations,
    }

    # Validar relat√≥rio
    try:
        validate(instance=report, schema=DEPS_REPORT_SCHEMA)
        logger.info("‚úÖ Relat√≥rio de depend√™ncias validado")
    except ValidationError as e:
        logger.warning(f"‚ö†Ô∏è  Relat√≥rio inv√°lido: {e.message}")

    return report


def display_summary(report):
    """
    Exibe sum√°rio do relat√≥rio.

    Args:
        report: Relat√≥rio de depend√™ncias
    """
    print("\nüìä Sum√°rio de Depend√™ncias - Slice/ALIVE Providers")
    print("=" * 60)
    print(f"Total de pacotes: {report['total_packages']}")

    # Resumo de riscos
    risk_counts = {}
    for pkg in report["packages"]:
        risk = pkg.get("license_risk", "unknown")
        risk_counts[risk] = risk_counts.get(risk, 0) + 1

    print("\nüè∑Ô∏è  Distribui√ß√£o de risco de licen√ßas:")
    risk_colors = {"low": "üü¢", "medium": "üü°", "high": "üî¥", "unknown": "‚ö™"}
    for risk, count in sorted(risk_counts.items()):
        icon = risk_colors.get(risk, "‚ùì")
        print(f"  {icon} {risk.capitalize():8}: {count:3} pacotes")

    # Top licen√ßas
    print("\nüìú Top licen√ßas:")
    top_licenses = sorted(
        report["license_summary"].items(), key=lambda x: x[1], reverse=True
    )[:5]
    for license_name, count in top_licenses:
        print(f"  {license_name:25}: {count:3} pacotes")

    # Vulnerabilidades
    security_count = len(report.get("security_issues", []))
    if security_count > 0:
        print(f"\nüîí Vulnerabilidades de seguran√ßa: {security_count}")
    else:
        print("\nüîí Nenhuma vulnerabilidade conhecida encontrada")

    # Recomenda√ß√µes
    recommendations = report.get("recommendations", [])
    if recommendations:
        print(f"\nüí° Recomenda√ß√µes: {len(recommendations)}")
        for rec in recommendations[:3]:  # Top 3
            priority_icon = {
                "critical": "üö®",
                "high": "‚ö†Ô∏è ",
                "medium": "üí°",
                "low": "‚ÑπÔ∏è ",
            }
            icon = priority_icon.get(rec.get("priority"), "üí°")
            print(f"  {icon} {rec['message']}")
    else:
        print("\n‚úÖ Nenhuma recomenda√ß√£o cr√≠tica")


def main():
    """Executa an√°lise completa de depend√™ncias."""
    import argparse

    parser = argparse.ArgumentParser(description="An√°lise de depend√™ncias e licen√ßas")
    parser.add_argument(
        "--output",
        type=str,
        default="deps_report.json",
        help="Arquivo de sa√≠da do relat√≥rio",
    )
    parser.add_argument(
        "--no-security", action="store_true", help="Pula auditoria de seguran√ßa"
    )
    parser.add_argument(
        "--format",
        choices=["json", "summary"],
        default="summary",
        help="Formato de sa√≠da",
    )
    parser.add_argument(
        "--filter-risk",
        choices=["low", "medium", "high", "unknown"],
        help="Filtrar apenas pacotes com risco espec√≠fico",
    )

    args = parser.parse_args()

    logger.info("üìä Iniciando An√°lise de Depend√™ncias - Slice/ALIVE Providers")
    logger.info("=" * 60)

    # Coletar pacotes
    packages = get_installed_packages()

    # Auditoria de seguran√ßa
    security_issues = []
    if not args.no_security:
        security_issues = run_security_audit()
    else:
        logger.info("‚è≠Ô∏è  Pulando auditoria de seguran√ßa (--no-security)")

    # Gerar relat√≥rio
    report = generate_deps_report(packages, security_issues)

    # Filtrar por risco se solicitado
    if args.filter_risk:
        filtered_packages = [
            pkg
            for pkg in report["packages"]
            if pkg.get("license_risk") == args.filter_risk
        ]
        report["packages"] = filtered_packages
        report["total_packages"] = len(filtered_packages)
        logger.info(
            f"üîç Filtrado para {len(filtered_packages)} pacotes com risco '{args.filter_risk}'"
        )

    # Salvar relat√≥rio
    output_path = Path(args.output)
    with open(output_path, "w") as f:
        json.dump(report, f, indent=2, default=str)
    logger.info(f"üíæ Relat√≥rio salvo em: {output_path}")

    # Exibir resultado
    if args.format == "summary":
        display_summary(report)
    elif args.format == "json":
        print(json.dumps(report, indent=2, default=str))

    # Status de sa√≠da baseado em recomenda√ß√µes cr√≠ticas
    critical_recommendations = [
        rec
        for rec in report.get("recommendations", [])
        if rec.get("priority") in ["critical", "high"]
    ]

    if critical_recommendations:
        logger.warning(
            f"‚ö†Ô∏è  {len(critical_recommendations)} recomenda√ß√µes cr√≠ticas encontradas"
        )
        sys.exit(1)
    else:
        logger.info("‚úÖ An√°lise conclu√≠da - nenhum problema cr√≠tico encontrado")


if __name__ == "__main__":
    main()
